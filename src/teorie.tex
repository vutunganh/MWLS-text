\chapter{Teorie}

\section{Definice a značení}

Symbolem $\hat n$ značíme množinu čísel $\{1, 2, \ldots, n\}$. Vektory $\vec{v} \in \reals^n$ značíme písmenem s šipkou. Matice $\mx{A}$ značíme zdvojeným písmenem. Normu značíme $\norm{\cdot}_k$. Není-li spodní index $k$ u normy specifikován, pak se myslí Euklidovská norma $\norm{\cdot}_2$. Euklidovskou vzdálenost mezi dvojicí vektorů $\vec{u}$ a $\vec{v}$ tedy značíme $\norm{\vec{u} - \vec{v}}$. V této kapitole se používá porovnání mezi vektory $\vec{u} < \vec{v}$, kde $\vec{u}, \vec{v} \in \reals^d$, které zavádíme takto: vektor $\vec{u}$ je menší než vektor $\vec{v}$, pokud $\forall i \in \hat{d}: \vec{u_i} < \vec{v_i}$, tedy je menší po složkách.

\section{Metoda nejmenších čtverců}

Nechť je dána sada dat $\{\vec{x_i}, \vec{y_i}\}_{i = 1}^k$, kde $x_i \in \reals^n$ a $y_i \in \reals^m$ a sada funkcí $f_1,\ldots,f_l$, kde $f_i: \reals^n \rightarrow \reals^m$. Úkolem je nalézt funkci
\begin{equation}
  \label{defi:ls}
  f = \sum_{i=1}^l c_if_i,
\end{equation}
s neznámými koeficienty $c_1,\ldots,c_l \in \reals$, která aproximuje sadu dat co nejlépe ve smyslu nejmenších čtverců s chybovou funkcí
\begin{equation}
\label{defi:ls-min}
  J(f) := \sum_{i=1}^k \norm{f(\vec{x_i}) - \vec{y_i}}^2 =
  \sum_{i=1}^k\norm{\sum_{j=1}^l c_jf_j(\vec{x_i}) - (\vec{y_i})}^2 =
  \sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l (c_j(f_j(\vec{x_i}))_u - (\vec{y_i})_u)^2.
\end{equation}

Minimalizační úlohu \ref{defi:ls-min} lze řešit pomocí nutné podmínky pro existenci lokálního extrému. Pro obecné $v \in \hat l$ platí
\begin{equation}
  \frac{\partial}{\partial c_v}J(f) = 2\sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l(c_j(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i}))_u.
\end{equation}

Položme tedy tyto derivace rovny nule a dostáváme pro jednotlivá $v \in \hat l$
\begin{multline}
\label{eq:solve-ls}
  2\sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l (c_j(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i}))_u = 0\\
  \sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l c_j(f_j(\vec{x_i}))_u (f_v(\vec{x_i}))_u = \sum_{i=1}^k\sum_{u=1}^m(\vec{y_i})_u(f_v(\vec{x_i}))_u\\
  \sum_{j=1}^l\underbrace{(\sum_{i=1}^k\sum_{u=1}^m(f_j(\vec{x_i}))_u (f_v(\vec{x_i}))_u)}_{\mx{A}_{vj}}c_j = \sum_{i=1}^k\sum_{u=1}^m(\vec{y_i})_u(f_v(\vec{x_i}))_u.\\
\end{multline}
Zaveďme matici $\mx{A} \in \reals^{l,l}$, kde 
\begin{equation}
\label{eq:solve-ls-lhs}
  \mx{A}_{vj} = \sum_{i=1}^k\sum_{u=1}^m = (f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u
\end{equation}
a vektor $\vec{c} = (c_1,\ldots,c_l)$. Nyní lze levou stranu rovnice \ref{eq:solve-ls} zapsat jako $\mx{A}\vec{c}$. Dále zaveďme vektor $\vec{b} = (b_1,\ldots,b_l)$, kde pro jednotlivá $v \in \hat l$ platí
\begin{equation}
\label{eq:solve-ls-rhs}
  \vec{b}_v = \sum_{i=1}^k\sum_{u=1}^m (\vec{y_i})_u (f_v(\vec{x_i}))_u.
\end{equation}
Dosaďme rovnice \ref{eq:solve-ls-lhs} a \ref{eq:solve-ls-rhs} do \ref{eq:solve-ls} a dostáváme soustavu lineárních rovnic s vektorem neznámých $\vec{c}$
\begin{equation}
  \mx{A}\vec{c} = \vec{b}.
\end{equation}

\section{Metoda vážených nejmenších čtverců}

Nechť je dána sada dat $S := \{\vec{x_i}, \vec{y_i}\}_{i = 1}^k$, kde $x_i \in \reals^n$ a $y_i \in \reals^m$, sada funkcí $f_1,\ldots,f_l$, kde $f_i: \reals^n \rightarrow \reals^m$ a váhová funkce $\theta(d): \reals \rightarrow \reals$. Úkolem je nalézt funkci
\begin{equation}
  \label{defi:wls}
  f(\vec{x}) = \sum_{i=1}^lc_i(\vec{x})f_i,
\end{equation}
s neznámými koeficienty $c_1,\ldots,c_l \in \reals$. Výsledkem obyčejné metody nejmenších čtverců je jedna funkce, která provádí ,,globální'' aproximaci, zatímco u metody vážených nejmenších čtverců je výsledná funkce závislá na vektoru $\vec{x}$, který chceme aproximovat. Obdobným způsobem lze zavést chybovou funkci
\begin{multline}
  \label{defi:wls-min}
  J(f(\vec{x})) := \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}})\norm{f(\vec{x_i}) - \vec{y_i}}^2 =
  \sum_{i=1}^k\theta(\norm{\vec{x} - \vec{x_i}})\norm{\sum_{j=1}^l c_j(\vec{x})f_j(\vec{x_i}) - \vec{y_i}}^2 =\\
  \sum_{i=1}^k\theta(\norm{\vec{x} - \vec{x_i}})\sum_{u=1}^m(\sum_{j=1}^l c_j(\vec{x})(f_j(\vec{x_i}))_u - (\vec{y_i})_u)^2.\\
\end{multline}

Minimalizační úlohu \ref{defi:wls-min} pro libovolné $\vec{x} \in \reals^n$ lze řešit pomocí nutné podmínky pro existenci lokálního extrému. Pro obecné $v \in \hat l$ platí
\begin{equation}
  \frac{\partial}{\partial c_v(\vec{x})}J(f(\vec{x})) = 2\sum_{i=1}^k\theta(\norm{\vec{x} - \vec{x_i}})\sum_{u=1}^m(\sum_{j=1}^l (c_j(\vec{x})(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i})_u)). 
\end{equation}
Položme tyto derivace rovny nule a dostáváme pro jednotlivá $v \in \hat l$
\begin{multline}
  \label{eq:solve-wls}
  2\sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\sum_{j=1}^l (c_j(\vec{x})(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i})_u)) = 0\\
  \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\sum_{j=1}^l c_j(\vec{x})(f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u) - (\vec{y_i})_u(f_v(\vec{x_i}))_u = 0\\
  \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\sum_{j=1}^l c_j(\vec{x})(f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u) = \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u\\
  \sum_{j=1}^l \underbrace{(\sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u)}_{A_{vj}}c_j(\vec{x}) = \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u.\\
\end{multline}
Zaveďme matici $\mx{A} \in \reals^{l,l}$, kde
\begin{equation}
  \label{eq:solve-wls-lhs}
  \mx{A}_{vj} = \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u,
\end{equation}
a vektor $\vec{c} = (c_1,\dots,c_l)$. Nyní lze levou stranu rovnice \ref{eq:solve-wls} psát jako $\mx{A}\vec{c}$. Dále zaveďme vektor $\vec{b} = (b_1,\ldots,b_l)$, kde pro jednotlivá $v \in \hat l$ platí
\begin{equation}
  \label{eq:solve-wls-rhs}
  \vec{b}_v = \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u.
\end{equation}
Dosaďme rovnice \ref{eq:solve-wls-lhs} a \ref{eq:solve-wls-rhs} do \ref{eq:solve-wls} a dostáváme soustavu lineárních rovnic s vektorem neznámých $\vec{c}$
\begin{equation}
  \mx{A}\vec{c} = \vec{b}.
\end{equation}

\section{Metoda pohyblivých vážených nejmenších čtverců}

Nechť je dána sada dat $S := \{\vec{x_i}, \vec{y_i}\}_{i = 1}^k$, kde $x_i \in \reals^n$ a $y_i \in \reals^m$, sada funkcí $f_1,\ldots,f_l$, kde $f_i: \reals^n \rightarrow \reals^m$, váhová funkce $\theta(d): \reals \rightarrow \reals$ a parametr $\varepsilon \in \reals$. Úkolem je nalézt funkci
\begin{equation}
  \label{defi:mwls}
  f(\vec{x},\varepsilon) = \sum_{i=1}^lc_i(\vec{x})f_i,
\end{equation}
s neznámými koeficienty $c_1, \ldots, c_l \in \reals$. Chybová funkce má tvar
\begin{equation}
  \label{defi:mwls-min}
  J(f(\vec{x},\varepsilon)) := \sum_{\vec{x_i}: \norm{\vec{x} - \vec{x_i}} \leq \varepsilon} \theta(\norm{\vec{x} - \vec{x_i}})\norm{f(\vec{x_i}, \varepsilon) - \vec{y_i}}^2.
\end{equation}
V metodě vážených nejmenších čtverců se pro tvorbu funkce $f(\vec{x})$ uvažovala celá množina vstupních dat $S$. V této variantě se omezíme pouze na podmnožinu $M \subseteq S$ takovou, že pro každý vektor $\vec{u} \in M$ takový, že $\norm{\vec{u} - \vec{x}} \leq \varepsilon$.

\section{Problém hledání nejbližších sousedů}

\begin{defi}
\label{defi:nns}
  Nechť je dána sada vektorů $S := \{\vec{x}_i\}_{i = 1}^n$, kde každé $\vec{x}_i \in \reals^d$. Naším úkolem nalézt pro vektor $\vec{q} \in \reals^d$ a $\delta \in \reals$ podmnožinu $M \subseteq S$ takovou, že pro všechny vektory $\vec{v} \in M$ platí, že $\norm{\vec{v} - \vec{q}} \leq \delta$ a pro všechny vektory $\vec{w} \in S \setminus M$ platí, že $\norm{\vec{w} - \vec{q}} > \delta$ a tedy $\vec{w} \not\in M$.
\end{defi}

Tuto úlohu lze řešit naivně algoritmem \ref{algo:naive-nns}, který pro každý vektor $\vec{u} \in S$ zjistí vzdálenost $\norm{\vec{u} - \vec{q}}$ a pokud je menší než $\delta$, pak $u$ přidá do výsledné množiny. Za předpokladu, že přidávání do výsledné množiny a počítání vzdálenosti mezi 2 vektory zvládneme v čase $O(1)$, tento algoritmus běží v čase $O(|S|)$ a zabírá $O(|S|)$ paměti.

\begin{algorithm}[ht!]
  \caption{Naivní řešení problému hledání nejbližších sousedů}
  \label{algo:naive-nns}
  \begin{algorithmic}
    \REQUIRE $S \subset \reals^n$, $\vec{q} \in \reals^n$, $\delta \in \reals$
    \ENSURE $M \subseteq S$
    \STATE $M \leftarrow \emptyset$
    \FORALL{$\vec{u} \in S$}
        \IF{$\norm{\vec{u} - \vec{q}} \leq \delta$}
          \STATE $M \leftarrow M \cup \vec{u}$
        \ENDIF
    \ENDFOR
    \RETURN $M$
  \end{algorithmic}
\end{algorithm}

V této sekci se budeme zabývat 2 řešeními tohoto problému, které byly použity v implementační části práce. Cílem je zejména snížit časovou složitost při hledání nejbližších sousedů.

\subsection{Cell linked list}

\label{defi:cll}
\begin{defi}
  Nechť je dána množina vektorů $S \in \reals^d$. Datová struktura \textit{cell linked list} rozdělí prostor $V := \reals^d$ na $d$-rozměrnou rovnoměrnou ,,hyperkrychlovou'' mřížku s délkou hrany $\varepsilon$ a v každé buňce si udržuje seznam vektorů z $S$, který se v ní nachází.\cite[s.~149--152]{computer_simulation_of_liquids}
\end{defi}

Cell linked list podporuje následující operace.

\begin{table}[ht!]
  \begin{tabular}{lll}
    Operace & Komentář\\
    CllBuild & Sestavení struktury.\\
    CllCount & Spočte pro sadu dat rozměry děleného prostoru.\\
    CllSearch & Nalezení sousedů.\\
    CllRebuild & Přenos buněk mezi cell linked listy.\\
    CllAdd & Přidání vektoru do struktury.\\
    CllRemove & Odebrání vektoru ze struktury.\\
  \end{tabular}
\end{table}

Pro cell linked list $C$ zavádíme následující pomocné funkce: $\varepsilon(C)$ vrátí délku hrany mřížky, kterou je rozdělen prostor $\reals^d$. Pro přistoupení k mřížce cell linked listu $C$ používáme $G(C)$. Chceme-li navíc vybrat konkrétní buňku, která se v $C$ nachází na souřadnicích $\vec{c}$, pak používáme značení $G(C, \vec{c})$. Vektor velikosti mřížky značíme $|S(G)|$. Množina vektorů $S$ uchovávána v cell linked listu $C$ značíme $S(C)$. Data, která si cell linked list uchovává na $\vec{c}$-tých souřadnicích, značíme $S(C, \vec{c})$.
Funkce $\min(C)$ vrátí vektor $\vec{p} \in \reals^d$, který má v $i$-té složce nejmenší hodnotu $i$-té složky přes všechny vektory $S(C)$. Tento postup je zachycen algoritmem \ref{algo:min-cll}. Funkce $\max(C)$ funguje obdobně, akorát na řádku \ref{algo:min-cll:infty} se do proměnné $\vec{p}$ nastaví vektor $(-\infty, \ldots, \infty)$ a na řádku \ref{algo:min-cll:minmax} budeme hledat maximum místo minima. Tento postup lze analogicky aplikovat na množinu vektorů a pro množinu vektorů $W \in \reals^d$ budeme operaci značit podobně $\min(W)$ resp. $\max(W)$.

\begin{algorithm}[!h]
  \caption{Funkce \textit{min} cell linked listu}
  \label{algo:min-cll}
  \begin{algorithmic}[1]
    \REQUIRE cell linked list $C$
    \ENSURE $\vec{p} \in \reals^d$
    \STATE $\vec{p} \leftarrow (\infty, \ldots, \infty)^T$ \label{algo:min-cll:infty}
      \FORALL{$\vec{u} \in S(G)$}
        \FORALL{$i \in {1, \ldots, d}$}
          \STATE $\vec{p_i} \leftarrow \min(\vec{p_i}, \vec{u_i})$ \label{algo:min-cll:minmax}
        \ENDFOR
    \ENDFOR
    \RETURN $\vec{p}$
  \end{algorithmic}
\end{algorithm}

Souřadnice vektoru $\vec{u}$ v cell linked listu $C$ budeme značit $I(C, \vec{u})$ a zavádíme jako $I(C, \vec{u}) := ((1 / \varepsilon(C)) \vec{u} + \min(C))$.

\textit{CllCount} pro sadu vektorů $S$ spočte velikost co nejmenší mřižky s délkou hrany $\varepsilon$ tak, aby bylo možné v mřížce $G$ zaindexovat každý vektor množiny $S$. Nejprve se spočte minimální a maximální hodnota přes všechny složky všech vektorů množiny $S$ a tyto vektory se uloží do. TODO: tohle se osemetne formuluje. Hodnotu \textit{CllCount} pro cell linked list $C$ spočteme vztahem $\mathit{CllCount}(C) := \lceil\max(C)/\varepsilon\rceil - \lfloor\min(C)/\varepsilon\rfloor + (1, \ldots, 1)^T$. Uvažme nejprve, že chceme do struktury ukládat pouze vektory s nezápornými složkami. Pak zjevně stačí, aby mřížka obsahovala $\lceil\max(C)/\varepsilon\rceil$ buněk. V případě, že připustíme i vektory se zápornými TODO: proof

Operace \textit{CllBuild} pro zadanou sadu vektorů $S$ sestrojí co nejmenší $d$-rozměrnou pravidelnou mřížku takovou, že pro každý vektor z množiny $S$ půjde nalézt buňku, do které patří. Funkcí \textit{CllCount} se spočte velikost výsledné mřížky a v každé buňce se vytvoří z počátku prázdný spojový seznam vektorů z $\reals^d$. Následně se pro každý vektor $\vec{u} \in S$ spočte jeho souřadnice v cell linked listu a připojí se ke spojovému seznamu. Tento algoritmus je doplněn pseudokódem \ref{algo:cll-build}.

\begin{algorithm}[h!]
  \caption{Algoritmus CllBuild}
  \label{algo:cll-build}
  \begin{algorithmic}
    \REQUIRE $S \subset \reals^d$, $\varepsilon \in \reals$
    \ENSURE cell linked list $C$ obsahující množinu $S$
    \STATE $\varepsilon(C) \leftarrow \varepsilon$
    \STATE $|S(G)| \leftarrow \max(S) - \min(S) + (1, \ldots, 1)^T$
    \STATE $G(C) \leftarrow d\hbox{-rozměrné pole prázdných spojových seznamů velikosti } |S(G)|$
    \FORALL{$\vec{u} \in S$}
      \STATE insert $\vec{u}$ into $G(C, I(C, \vec{u}))$
    \ENDFOR
    \RETURN $C$
  \end{algorithmic}
\end{algorithm}

Operace \textit{CllSearch} pro daný vektor $\vec{q} \in \reals^d$ a reálnou hodnotu $\delta \in \reals$ nalezne všechny vektory $\vec{u}$ v množině $S(C)$ takové, jejichž Euklidovská vzdálenost $\|\vec{u} - \vec{q}\|$ je menší než dané $\delta$. Nebude však naivně procházet celou množinu $S(C)$. Místo toho se podívá pouze vektory v buňkách se souřadnicemi $\vec{a}$ takovými, jejichž maximová norma $\|\vec{c} - \vec{a}\|_\infty$ je menší nebo rovna $r := \lceil\delta / \varepsilon(C)\rceil$. Lze si rozmyslet, že pokud se zvolí TODO: best r

\begin{algorithm}[h!]
  \caption{Algoritmus CllSearch}
  \label{algo:cll-build}
  \begin{algorithmic}
    \REQUIRE $\delta \in \reals$, $\vec{q} \in \reals^d$, cell linked list $C$
    \ENSURE $M \subseteq S(G)$
    \STATE $r \leftarrow \lceil\delta / \varepsilon(C)\rceil$
    \STATE $c \leftarrow i(\vec{q}, C)$
    \STATE $M \leftarrow \emptyset$
    \FORALL{$\vec{m} \in \reals^d: \|\vec{m} - \vec{c}\|_{\infty} < r$}
      \FORALL{$\vec{u} \in S(\vec{m}, C): \|\vec{u} - \vec{q}\| < \delta$}
        \STATE $M \leftarrow M \cup \vec{u}$
      \ENDFOR
    \ENDFOR
    \RETURN $M$
  \end{algorithmic}
\end{algorithm}

\subsection{K-d strom}

K-d strom je binárním vyhledávacím stromem, jehož klíči v jednotlivých vrcholech jsou body z $\reals{}^k$. Pro účely této sekce zavádíme následující značení: nechť $v = (v_0, ..., v_{k - 1})  \in \reals^k$ je klíčem vrcholu $P$, pak jednotlivé složky značíme $K_0(P), K_1(P), \ldots, K_{k - 1}(P)$. Ukazatele vrcholu $P$ na svého levého a pravého potomka značíme $L(P)$, resp. $R(P)$. Diskriminátor vrcholu $P$ značíme $D(P)$.

Každému vrcholu $P$ k--d stromu $T$ přiřazujeme tzv. diskriminátor, jenž je přirozeným číslem o $0$ do $k - 1$. Nechť $j := D(P)$, pak 

V této části popíšeme pouze ty operace, které jsou v práci použity. Jmenovitě vypouštíme operace přidávání prvku, mazání prvku a hledání sousedů v rozsahu.

