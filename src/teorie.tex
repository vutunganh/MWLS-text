\chapter{Teorie}

\section{Definice a značení}

Symbolem $\hat n$ značíme množinu čísel $\{1, 2, \ldots, n\}$. Vektory $\vec{v} \in \reals^n$ značíme písmenem s šipkou. Implicitně se předpokládá standardní báze. Matice $\mx{A}$ značíme zdvojeným písmenem. Normu značíme $\norm{\cdot}_k$. Není-li spodní index $k$ u normy specifikován, pak se myslí Euklidovská norma $\norm{\cdot}_2$. Euklidovskou vzdálenost mezi dvojicí vektorů $\vec{u}$ a $\vec{v}$ tedy značíme $\norm{\vec{u} - \vec{v}}$. V následujících kapitolách se používá porovnání mezi vektory $\vec{u} < \vec{v}$, kde $\vec{u}, \vec{v} \in \reals^d$, které zavádíme takto: vektor $\vec{u}$ je menší než vektor $\vec{v}$, pokud $\forall i \in \hat{d}: \vec{u_i} < \vec{v_i}$, tedy je menší po složkách.

\section{Metoda nejmenších čtverců}

Nechť je dána sada dat $\{\vec{x_i}, \vec{y_i}\}_{i = 1}^k$, kde $x_i \in \reals^n$ a $y_i \in \reals^m$ a sada funkcí $f_1,\ldots,f_l$, kde $f_i: \reals^n \rightarrow \reals^m$. Úkolem je nalézt funkci
\begin{equation}
  \label{defi:ls}
  f = \sum_{i=1}^l c_if_i,
\end{equation}
s neznámými koeficienty $c_1,\ldots,c_l \in \reals$, která aproximuje sadu dat co nejlépe ve smyslu nejmenších čtverců s chybovou funkcí
\begin{multline}
\label{defi:ls-min}
  J(f) := \sum_{i=1}^k \norm{f(\vec{x_i}) - \vec{y_i}}^2 =
  \sum_{i=1}^k\norm{\sum_{j=1}^l c_jf_j(\vec{x_i}) - (\vec{y_i})}^2 =\\
  \sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l (c_j(f_j(\vec{x_i}))_u - (\vec{y_i})_u)^2.\\
\end{multline}

Minimalizační úlohu \ref{defi:ls-min} lze řešit pomocí nutné podmínky pro existenci lokálního extrému. Pro obecné $v \in \hat l$ platí
\begin{equation}
  \frac{\partial}{\partial c_v}J(f) = 2\sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l(c_j(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i}))_u.
\end{equation}

Položme tedy tyto derivace rovny nule a dostáváme pro jednotlivá $v \in \hat l$
\begin{multline}
\label{eq:solve-ls}
  2\sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l (c_j(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i}))_u = 0\\
  \sum_{i=1}^k\sum_{u=1}^m\sum_{j=1}^l c_j(f_j(\vec{x_i}))_u (f_v(\vec{x_i}))_u = \sum_{i=1}^k\sum_{u=1}^m(\vec{y_i})_u(f_v(\vec{x_i}))_u\\
  \sum_{j=1}^l\underbrace{(\sum_{i=1}^k\sum_{u=1}^m(f_j(\vec{x_i}))_u (f_v(\vec{x_i}))_u)}_{\mx{A}_{vj}}c_j = \sum_{i=1}^k\sum_{u=1}^m(\vec{y_i})_u(f_v(\vec{x_i}))_u.\\
\end{multline}
Zaveďme matici $\mx{A} \in \reals^{l,l}$, kde 
\begin{equation}
\label{eq:solve-ls-lhs}
  \mx{A}_{vj} = \sum_{i=1}^k\sum_{u=1}^m = (f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u
\end{equation}
a vektor $\vec{c} = (c_1,\ldots,c_l)$. Nyní lze levou stranu rovnice \ref{eq:solve-ls} zapsat jako $\mx{A}\vec{c}$. Dále zaveďme vektor $\vec{b} = (b_1,\ldots,b_l)$, kde pro jednotlivá $v \in \hat l$ platí
\begin{equation}
\label{eq:solve-ls-rhs}
  \vec{b}_v = \sum_{i=1}^k\sum_{u=1}^m (\vec{y_i})_u (f_v(\vec{x_i}))_u.
\end{equation}
Dosaďme rovnice \ref{eq:solve-ls-lhs} a \ref{eq:solve-ls-rhs} do \ref{eq:solve-ls} a dostáváme soustavu lineárních rovnic s vektorem neznámých $\vec{c}$
\begin{equation}
  \label{eq:sle-ls}
  \mx{A}\vec{c} = \vec{b}.
\end{equation}
Regularitu matice $\mx{A}$ lze předpokládat, pokud jsou lineárně nezávislé funkce $f_1, \ldots, f_l$ a $\vec{x_1}, \ldots, \vec{x_n}$ jsou po dvojicích různá. Vyřešením soustavy \ref{eq:sle-ls} získáme hodnoty hledaných koeficientů.

\section{Metoda vážených nejmenších čtverců}

Nechť je dána sada dat $S := \{\vec{x_i}, \vec{y_i}\}_{i = 1}^k$, kde $x_i \in \reals^n$ a $y_i \in \reals^m$, sada funkcí $f_1,\ldots,f_l$, kde $f_i: \reals^n \rightarrow \reals^m$ a váhová funkce $\theta(d): \reals \rightarrow \reals$. Úkolem je nalézt funkci
\begin{equation}
  \label{defi:wls}
  f(\vec{x}) = \sum_{i=1}^lc_i(\vec{x})f_i,
\end{equation}
s neznámými koeficienty $c_1,\ldots,c_l \in \reals$. Výsledkem obyčejné metody nejmenších čtverců je jedna funkce, která provádí ,,globální'' aproximaci, zatímco u metody vážených nejmenších čtverců je výsledná funkce závislá na vektoru $\vec{x}$, který chceme aproximovat. Obdobným způsobem lze zavést chybovou funkci
\begin{multline}
  \label{defi:wls-min}
  J(f(\vec{x})) := \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}})\norm{f(\vec{x_i}) - \vec{y_i}}^2 =\\
  \sum_{i=1}^k\theta(\norm{\vec{x} - \vec{x_i}})\norm{\sum_{j=1}^l c_j(\vec{x})f_j(\vec{x_i}) - \vec{y_i}}^2 =\\
  \sum_{i=1}^k\theta(\norm{\vec{x} - \vec{x_i}})\sum_{u=1}^m(\sum_{j=1}^l c_j(\vec{x})(f_j(\vec{x_i}))_u - (\vec{y_i})_u)^2.\\
\end{multline}

Minimalizační úlohu \ref{defi:wls-min} pro libovolné $\vec{x} \in \reals^n$ lze řešit pomocí nutné podmínky pro existenci lokálního extrému. Pro obecné $v \in \hat l$ platí
\begin{equation}
  \frac{\partial}{\partial c_v(\vec{x})}J(f(\vec{x})) = 2\sum_{i=1}^k\theta(\norm{\vec{x} - \vec{x_i}})\sum_{u=1}^m(\sum_{j=1}^l (c_j(\vec{x})(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i})_u)). 
\end{equation}
Položme tyto derivace rovny nule a dostáváme pro jednotlivá $v \in \hat l$
\begin{multline}
  \label{eq:solve-wls}
  2\sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\sum_{j=1}^l (c_j(\vec{x})(f_j(\vec{x_i}))_u - (\vec{y_i})_u)(f_v(\vec{x_i})_u)) = 0\\
  \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\sum_{j=1}^l c_j(\vec{x})(f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u) - (\vec{y_i})_u(f_v(\vec{x_i}))_u = 0\\
  \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\sum_{j=1}^l c_j(\vec{x})(f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u) =\\ \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u\\
  \sum_{j=1}^l \underbrace{(\sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u)}_{\mx{A}_{vj}}c_j(\vec{x}) =\\ \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u.\\
\end{multline}
Zaveďme matici $\mx{A} \in \reals^{l,l}$, kde
\begin{equation}
  \label{eq:solve-wls-lhs}
  \mx{A}_{vj} = \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (f_j(\vec{x_i}))_u(f_v(\vec{x_i}))_u,
\end{equation}
a vektor $\vec{c} = (c_1,\dots,c_l)$. Nyní lze levou stranu rovnice \ref{eq:solve-wls} psát jako $\mx{A}\vec{c}$. Dále zaveďme vektor $\vec{b} = (b_1,\ldots,b_l)$, kde pro jednotlivá $v \in \hat l$ platí
\begin{equation}
  \label{eq:solve-wls-rhs}
  \vec{b}_v = \sum_{i=1}^k \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u.
\end{equation}
Dosaďme rovnice \ref{eq:solve-wls-lhs} a \ref{eq:solve-wls-rhs} do \ref{eq:solve-wls} a dostáváme soustavu lineárních rovnic s vektorem neznámých $\vec{c}$
\begin{equation}
  \label{eq:sle-wls}
  \mx{A}\vec{c} = \vec{b}.
\end{equation}
% TODO: citace regularity
Regularitu matice $\mx{A}$ lze předpokládat, pokud jsou lineárně nezávislé funkce $f_1, \ldots, f_l$ a $\vec{x_1}, \ldots, \vec{x_n}$ jsou po dvojicích různá. Vyřešením soustavy \ref{eq:sle-wls} získáme hodnoty hledaných koeficientů.

\section{Metoda pohyblivých vážených nejmenších čtverců}
\label{sec:mwls}

Nechť je dána sada dat $S := \{\vec{x_i}, \vec{y_i}\}_{i = 1}^k$, kde $x_i \in \reals^n$ a $y_i \in \reals^m$, sada funkcí $f_1,\ldots,f_l$, kde $f_i: \reals^n \rightarrow \reals^m$, váhová funkce $\theta(d): \reals \rightarrow \reals$ a parametr $\varepsilon \in \reals$. Úkolem je nalézt funkci
\begin{equation}
  \label{defi:mwls}
  f(\vec{x},\varepsilon) = \sum_{i=1}^lc_i(\vec{x})f_i,
\end{equation}
s neznámými koeficienty $c_1, \ldots, c_l \in \reals$. Chybová funkce má tvar
\begin{equation}
  \label{defi:mwls-min}
  J(f(\vec{x},\varepsilon)) := \sum_{\{\vec{x_i} : \norm{\vec{x_i} - \vec{x}} \leq \varepsilon\}} \theta(\norm{\vec{x} - \vec{x_i}})\norm{f(\vec{x_i}, \varepsilon) - \vec{y_i}}^2.
\end{equation}
V metodě vážených nejmenších čtverců se pro tvorbu funkce $f(\vec{x})$ uvažovala celá množina vstupních dat $S$. V této variantě se omezíme pouze na podmnožinu $M \subseteq S$ takovou, že pro každý vektor $\vec{u} \in M$ platí $\norm{\vec{u} - \vec{x}} \leq \varepsilon$.

Minimalizace chybové funkce \ref{defi:mwls-min} se příliš neliší od \ref{eq:solve-wls}. Výsledkem je opět soustava lineárních rovnic
\begin{equation}
  \label{eq:sle-mwls}
  \mx{A}\vec{c} = \vec{b},
\end{equation}
kde $\mx{A} \in \reals^{l,l}$ a
\begin{equation}
  \label{eq:solve-mwls-lhs}
  \mx{A}_{vj} := \sum_{\{\vec{x_i}: \norm{\vec{x} - \vec{x_i}} \leq \varepsilon\}} \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u = 1}^m (f_j(\vec{x_i}))_u (f_v(\vec{x_i}))_u,
\end{equation}
$\vec{c}$ je vektor neznámých koeficientů $(\vec{c_1}, \ldots, \vec{c_l})^T$ a $b \in \reals^l$, kde
\begin{equation}
  \label{eq:solve-mwls-rhs}
  \vec{b}_v = \sum_{\{\vec{x_i}: \norm{\vec{x} - \vec{x_i}} \leq \varepsilon \}} \theta(\norm{\vec{x} - \vec{x_i}}) \sum_{u=1}^m (\vec{y_i})_u(f_v(\vec{x_i}))_u.
\end{equation}

Regularitu matice $\mx{A}$ lze předpokládat, pokud jsou funkce $f_1, \ldots, f_l$ lineárně nezávislé a hodnoty $\vec{x_1}, \ldots, \vec{x_l}$ jsou po dvou různé. Vyřešením soustavy \ref{eq:sle-mwls} získáme hledané koeficienty $c_1, \ldots, c_l$.

Metoda pohyblivých (i nepohyblivých) vážených nejmenších čtverců patří mezi tzv. \textit{meshfree} metody pro rekonstrukci funkce mimo pravidelnou mřížku. Nevyžadují, aby vstupní (vzorová) data $S$ byla umístěná na pravidelné mřížce. Také neexistovalo žádné omezení pro hodnotu vektoru $\vec{x} \in \reals^n$, k němuž jsme chtěli sestrojit aproximaci $f(\vec{x}, \varepsilon)$, což nemusí nutně platit pro metody, které vyžadují po vstupních datech, aby byla umístěná na pravidelné mřížce.

\section{Problém hledání sousedů v daném rozsahu}

\begin{defi}
  \label{defi:nns}
  Nechť je dána sada vektorů $S := \{\vec{x}_i\}_{i = 1}^n$, kde každé $\vec{x}_i \in \reals^d$. Naším úkolem nalézt pro vektor $\vec{q} \in \reals^d$ a $\delta \in \reals$ podmnožinu $M \subseteq S$ takovou, že pro všechny vektory $\vec{v} \in M$ platí, že $\norm{\vec{v} - \vec{q}} \leq \delta$ a pro všechny vektory $\vec{w} \in S \setminus M$ platí, že $\norm{\vec{w} - \vec{q}} > \delta$ a tedy $\vec{w} \not\in M$.
\end{defi}

Tuto úlohu lze řešit naivně algoritmem \ref{algo:naive-nns}, který pro každý vektor $\vec{u} \in S$ zjistí vzdálenost $\norm{\vec{u} - \vec{q}}$ a pokud je menší než $\delta$, pak $u$ přidá do výsledné množiny. Za předpokladu, že přidávání do výsledné množiny a počítání vzdálenosti mezi 2 vektory zvládneme v čase $O(1)$, tento algoritmus běží v čase $O(|S|)$ a zabírá $O(|S|)$ paměti.

\begin{algorithm}[ht!]
  \caption{Naivní řešení problému hledání nejbližších sousedů}
  \label{algo:naive-nns}
  \begin{algorithmic}
    \REQUIRE $S \subset \reals^n$, $\vec{q} \in \reals^n$, $\delta \in \reals$
    \ENSURE $M \subseteq S$
    \STATE $M \leftarrow \emptyset$
    \FORALL{$\vec{u} \in S$}
        \IF{$\norm{\vec{u} - \vec{q}} \leq \delta$}
          \STATE $M \leftarrow M \cup \vec{u}$
        \ENDIF
    \ENDFOR
    \RETURN $M$
  \end{algorithmic}
\end{algorithm}

V této sekci se budeme zabývat 2 řešeními tohoto problému, které byly použity v implementační části práce. Cílem je zejména snížit časovou složitost při hledání nejbližších sousedů.

\subsection{Cell linked list}

\label{defi:cll}
\begin{defi}
  Nechť je dána množina vektorů $S \in \reals^d$. Datová struktura \textit{cell linked list} rozdělí prostor $V := \reals^d$ na $d$-rozměrnou rovnoměrnou mřížku s délkou hrany $\varepsilon$ a v každé buňce si udržuje seznam vektorů z $S$, který se v ní nachází.\cite[s.~149--152]{computer_simulation_of_liquids}
\end{defi}

Cell linked list lze implementovat pomocí $d$-rozměrného pole, které si každé buňce ukládá spojový seznam vektorů, který se v příslušné buňce nachází.

\noindent Cell linked list podporuje následující operace.

\begin{table}[ht!]
  \begin{tabular}{lll}
    Operace & Komentář\\
    CllBuild & Sestavení struktury.\\
    CllSearch & Nalezení sousedů.\\
  \end{tabular}
\end{table}

Pro cell linked list $C$ zavádíme následující pomocné funkce: $\varepsilon(C)$ vrátí délku hrany mřížky, kterou je rozdělen prostor $\reals^d$. Pro přistoupení k mřížce cell linked listu $C$ používáme $G(C)$. Chceme-li navíc vybrat konkrétní buňku, která se v $C$ nachází na souřadnicích $\vec{c}$, pak používáme značení $G(C, \vec{c})$. Vektor velikostí mřížky značíme $|S(G)|$. Množinu vektorů $S$ uchovávána v cell linked listu $C$ značíme $S(C)$. Data, která si cell linked list uchovává na $\vec{c}$-tých souřadnicích, značíme $S(C, \vec{c})$.

Pro libovolný vektor $\vec{u} \in \reals^d$ a cell linked list $C$ se nabízí otázka, do které buňky vektor $\vec{u}$ vložit. Nejpřirozenější volbou je umístit ji do buňky na indexech $(\floor{\vec{u}_1/\varepsilon(C)}, \ldots, \floor{\vec{u}_d/\varepsilon(C)})$. Tento výpočet budeme dále značit jako $I(C, \vec{u})$. Může se stát, že se vektor bude umisťovat do buňky s zápornými souřadnicemi. V této sekci povolíme indexaci pole zápornými čísly. Také budeme předpokládat, že pole jsou nekonečná, tzn. lze je indexovat libovolným číslem $i \in \mathbb{Z}$.

Operace \textit{CllBuild} umístí zadanou sadu vektorů $S$ do cell linked listu $C$. Pro každý vektor $\vec{u} \in S$ se spočte $\vec{c} = I(C, \vec{u})$ a umístí se do buňky na indexu $\vec{c}$. Tento algoritmus je doplněn pseudokódem \ref{algo:cll-build}.

\begin{algorithm}[h!]
  \caption{CllBuild}
  \label{algo:cll-build}
  \begin{algorithmic}
    \REQUIRE $S \subset \reals^d$, $\varepsilon \in \reals$
    \ENSURE cell linked list $C$ obsahující množinu $S$
    \STATE $C \leftarrow$ prázdný cell linked list
    \FORALL{$\vec{u} \in S$}
      \STATE $\vec{c} \leftarrow I(C, \vec{u})$
      \STATE $S(C, \vec{c}) \leftarrow S(C, \vec{c}) \cup \vec{u}$
    \ENDFOR
    \RETURN $C$
  \end{algorithmic}
\end{algorithm}

Operace \textit{CllSearch} pro daný vektor $\vec{q} \in \reals^d$ a reálnou hodnotu $\delta \in \reals$ nalezne všechny vektory $\vec{u}$ v množině $S(C)$ takové, jejichž Euklidovská vzdálenost $\|\vec{u} - \vec{q}\|$ je menší než dané $\delta$. Nebude však naivně procházet celou množinu $S(C)$. Místo toho se podívá pouze vektory v buňkách se souřadnicemi $\vec{a}$ takovými, jejichž maximová norma $\|I(C, \vec{q}) - \vec{a}\|_\infty$ je menší nebo rovna $r := \ceil{\delta / \varepsilon(C)}$. Intuice za volbou $r$ je taková, že nechceme vybírat takové buňky, které mají prázdný průnik s pomyslnou hypersférou se středem v $\vec{q}$ a poloměrem $\delta$, protože nemohou obsahovat vektory, které jsou dostatečně ,,blízko'' k vektoru $\vec{q}$. Tento postup je zapsán do pseudokódu \ref{algo:cll-search}.

Složitost algoritmu \textit{CllSearch} není snadné určit bez znalosti rozdělení dat $S(C)$ a proto jej vynecháváme.

\begin{algorithm}[h!]
  \caption{CllSearch}
  \label{algo:cll-search}
  \begin{algorithmic}
    \REQUIRE $\delta \in \reals$, $\vec{q} \in \reals^d$, cell linked list $C$
    \ENSURE $M \subseteq S(G)$
    \STATE $r \leftarrow \lceil\delta / \varepsilon(C)\rceil$
    \STATE $c \leftarrow I(C, \vec{q})$
    \STATE $M \leftarrow \emptyset$
    \FORALL{$\vec{m} \in \mathbb{Z}^d: \|\vec{m} - \vec{c}\|_{\infty} < r$}
      \FORALL{$\vec{u} \in S(C, \vec{m}): \|\vec{u} - \vec{q}\| < \delta$}
        \STATE $M \leftarrow M \cup \vec{u}$
      \ENDFOR
    \ENDFOR
    \RETURN $M$
  \end{algorithmic}
\end{algorithm}

\subsection{K-d strom}

K-d strom je binární vyhledávací strom, který si ve vrcholu $V$ pamatuje diskriminátor $m \in \hat k$ a vektory $\vec{B_l} \in \reals^k$ a $\vec{B_r} \in \reals^k$. Podstrom zakořeněný ve vrcholu $V$ si pamatuje pouze vektory $\vec{u} \in \reals^k$, které nejsou menší než $\vec{B_l}$ a nejsou větší než $\vec{B_r}$, tzn. $\vec{B_l} \leq \vec{u} \leq \vec{B_r}$. Levého potomka vrcholu $V$ značíme $L(V)$, pravého $R(V)$. Pokud budeme přistupovat k položkám vrcholu $V$, pak píšeme $m(V)$, resp. $\vec{B_l}(V)$ a $\vec{B_r}(V)$.

V této části popíšeme pouze ty operace k-d stromu, které jsou v práci použity. Jmenovitě vypouštíme operace přidávání prvku, mazání prvku a hledání $k$ nejbližších sousedů.

Konstrukce k-d stromu probíhá rekurzivně. Parametry pro sestavení vrcholu je množina vstupních dat $S$, číslo $h$ udávající velikost listu a vektory $B_l$ a $B_r$. Pro konstrukci zcela nového stromu se zavolá funkce \textit{kdBuild} s parametry $S, h, (-\infty, \ldots, -\infty)^T, (\infty, \ldots, \infty)^T$, které postupně udávají množinu ukládaných dat, maximální velikost listu a spodní a horní hranici pro vektory, které jsou v podstromě udržovány. Je-li velikost množiny $S$ menší než parametr $h$, pak vracíme list, který obsahuje množinu $S$ a vektory $\vec{B_l}$ a $\vec{B_r}$. Jinak začneme určením diskriminátoru $p \in \hat k$ tak, aby se maximalizoval rozdíl vektoru s nejmenší $p.$ složkou a vektoru s největší $p.$ složkou. Jinými slovy se hledá dimenze $p$ s největším rozdílem mezi největší a nejmenší $p.$ složkou. Po nalezení $p$ se hledá medián $q$ z množiny $\{(\vec{u})_p | \forall \vec{u} \in S\}$ $p.$ složek všech vektorů množiny $S$. Vytvoří se vektory $\vec{b_l} = ((\vec{B_l})_1, \ldots, (\vec{B_l})_{p-1}, q, (\vec{B_l})_{p+1}, \ldots, (\vec{B_l})_k)$ a $\vec{b_r} = ((\vec{B_r})_1, \ldots, (\vec{B_r})_{p-1}, q, (\vec{B_r})_{p+1}, \ldots, (\vec{B_r})_k)$. Rozdělíme množinu $S$ na množiny $S_l$ a $S_r$, kde $S_l = {\forall\vec{u} \in S: \vec{u} < \vec{b_l}}$ a $S_r = S \setminus S_l$. Vytvoří se vrchol k-d stromu $V$, kde $m(V) = p$, $\vec{B_l}(V) = \vec{B_l}$ a $\vec{B_l}(V) = \vec{B_r}$. Levý potomek vrcholu $V$ bude výsledek volání funkce \textit{kdBuild} s parametry $S_l, h, \vec{B_l}, \vec{b_l}$. Pravý potomek bude obdobně výsledek volání funkce \textit{kdBuild} s parametry $S_r, h, \vec{B_r}, \vec{b_r}$.

Z koncové podmínky rekurzivního sestavení stromu bude mít výsledný strom $\lceil |S| / h \rceil - 1$ (dále už budeme označovat pouze jako $n$) listů. Ze struktury binárního vyhledávacího stromu plyne, že strom bude mít $O(n\log(n))$ vrcholů. Pro lineární hledání mediánu v každém vytváření vrcholu stromu lze předzpracovat data seřazením přes každou složku, což zabere $O(k|S|\log(|S|))$ času. Pro sestavení každého vrcholu se musí projít předaná množina dat $S$ pro nalezení diskriminátoru. Tento rekurentní vztah lze zapsat jako $T(|S|) = 2T(|S|/2) + k|S|$ a z Mistrovské věty lze určit celkový čas pro sestavení stromu jako $O(k|S|\log(|S|))$.

\begin{algorithm}[h!]
  \caption{Algoritmus sestavení k-d stromu (kdBuild)}
  \label{algo:kd-tree-build}
  \begin{algorithmic}
    \REQUIRE $S = \{\forall \vec{u} \in S: \vec{u} \in \reals^k\}, d \in \reals, \vec{B_l} \in \reals^k, \vec{B_r} \in \reals^k$
    \ENSURE kořen k-d stromu $T$
    \IF{$|S| < s$}
      \RETURN KdNode($S, d, \emptyset, \emptyset, (\vec{B_l}), (\vec{B_r})$)
    \ENDIF
    \STATE $p \leftarrow -\infty$
    \FORALL{$\vec{u}, \vec{v} \in S$, kde $\vec{u} \neq \vec{v}$}
      \FORALL{$i \in 0, \ldots, k-1$}
        \STATE $p \leftarrow \max(p, \vec{u}_i - \vec{v}_i$)
      \ENDFOR
    \ENDFOR
    \STATE $m \leftarrow \textrm{median}(\{\vec{u}_p: \forall \vec{u} \in S\})$ 
    \STATE $\vec{b_l} \leftarrow ((\vec{B_l})_1, \ldots, (\vec{B_l})_{p-1}, m, (\vec{B_l})_{p+1}, \ldots, (\vec{B_l})_k)$
    \STATE $\vec{b_r} \leftarrow ((\vec{B_r})_1, \ldots, (\vec{B_r})_{p-1}, m, (\vec{B_r})_{p+1}, \ldots, (\vec{B_r})_k)$
    \STATE $s_l \leftarrow \emptyset$
    \STATE $s_r \leftarrow \emptyset$
    \FORALL{$\vec{u} \in S$}
      \IF{$\vec{u} \leq \vec{b_l}$}
        \STATE $\vec{s_l} \leftarrow \vec{s_l} \cup \vec{u}$
      \ELSE
        \STATE $\vec{s_r} \leftarrow \vec{s_r} \cup \vec{u}$
      \ENDIF
    \ENDFOR
    \RETURN KdNode($S, p, \textrm{kdBuild}(\vec{s_l}, d, \vec{B_l}, \vec{b_l}), \textrm{kdBuild}(\vec{s_r}, d, \vec{B_r}, \vec{b_r}), \vec{B_l}, \vec{B_r}$)
  \end{algorithmic}
\end{algorithm}

Algoritmus pro hledání všech záznamů, které leží v hyperkouli $B$ se středem ve vektoru $\vec{q}$ a poloměrem $\delta$ také pracuje rekurzivně. Parametry pro hledání jsou vrchol stromu $V$, který algoritmus zrovna prohledává, vektor $\vec{q}$ a reálné číslo $\delta \in \reals$ určující data, která chceme hledat. Vektory $\vec{B_l}(V)$ a $\vec{B_r}(V)$ určují pomyslný hyperkvádr $H$ v prostoru $\reals^k$. Algoritmus zjistí, jestli má hyperkvádr $H$ a $B$ neprázdný průnik. Pokud $H \cap B = \emptyset$, pak neexistuje záznam, který by ležel v $B$ a rekurze končí. Pokud $H \cap B \neq \emptyset$, pak v podstromě zakořeněném ve vrcholu $V$ mohou existovat záznamy, které chceme nalézt a rekurze se musí zanořit do obou potomků. Zpravidla se nejprve zanořuje do potomka, jehož hyperkvádr má ,,větší'' průnik s hyperkoulí $B$. Dojde-li algoritmus do listu, pak musí zkontrolovat platnost $\norm{\vec{q} - \vec{u}} \leq \delta$ každý záznam $\vec{u}$, který se v listu nachází. 

\begin{algorithm}
  \label{algo:kd-tree-range-search}
  \caption{Algoritmus pro }
  \begin{algorithmic}
    \REQUIRE vrchol k-d stromu
  \end{algorithmic}
\end{algorithm}

\subsection{Další možná řešení}

Pro řešení problému existuje řada dalších metod. Datová struktura \textit{quadtree} funguje obdobně jako k-d strom, ale pouze v 2D prostoru. Každé vrchol stromu má 4 potomky, kteří odpovídají rozdělení roviny na 4 části pomocí 2 na sobě kolmých přímek tak, aby v každé části byla přibližně čtvrtina vstupu. Pro obecný k-dimenzionální prostor bude mít každý vrchol $2^k$ potomků, čímž exponenciálně poroste počet vrcholů takového stromu. V praxi se například používá \textit{octree}, který pracuje jako quadtree v 3D prostoru, pro práci s grafikou.\cite{octree-usage}

K-d strom je v podstatě binární vyhledávací strom. Vyhledávací stromy mohou však být i obecné a v jednotlivých vrcholech mohou mít více dat a tím pádem i více potomků. Příkladem takové struktury je \textit{(a, b)-strom}, kde kořen může mít 2 až $b$ potomků a vnitřní vrcholy mají $a$ až $b$ potomků.\cite[s.~190--198]{pruvodce} Tento koncept se dá modifikovat i pro náš problém a příkladem takové modifikace je \textit{R-strom}.\cite{r-tree}

Operace přidávání, odebírání a modifikace prvků v k-d stromě mají slabinu v tom, že jejich provedením může vzniknout nevyvážený strom. Nevyváženosti v binárních vyhledávacích stromech většinou řešíme pomocí rotací vrcholů, ale mohl by nastat problém kvůli nerovnosti diskriminátoru rotovaného vrcholu a jeho rodiče. Kvůli tomu by se musel podstrom zakořeněný v rodiči rotovaného vrcholu celý přestavět, což není příliš časově efektivní. Jednou z modifikací k-d stromu, která si s tímto problémem umí poradit je Bkd-strom, který mj. pravidelně strom přestavuje.\cite{bkd-tree}
