\chapter{Realizace}

\section{Programovací jazyk Julia}

Julia je relativně nový programovací jazyk (poprvé se objevil v roce 2012\cite{julia-first}) a proto by bylo na místě jej představit a zvýraznit některé důležité, ne zcela obvyklé vlastnosti.

Julia je dynamicky typovaný jazyk. Oproti známějším, dynamicky typovaným jazykům jako je například Python\footnote{pomineme-li typové anotace} nebo Javascript lze u proměnných, třídních proměnných a parametrů funkcí specifikovat typ. Pro tento účel je existuje postfixový operátor \texttt{::<název typu>}. Například \texttt{a = 20} vytvoří proměnnou \texttt{a} s typem \texttt{Int64} (64bitové celé číslo), zatímco \texttt{a::Int8 = 20} vytvoří proměnnou \texttt{a} s typem \texttt{Int8} (8bitové celé číslo). Specifikace typu se však nikdy explicitně nevyžaduje a vždy je možné ji vynechat.

Nicméně v některých případech je výhodnější typ uvést. U třídních proměnných je vždy lepší typ uvést z výkonnostních důvodů. Pokud typ není specifikován, pak musí být schopen udržet v sobě libovolný objekt a z tohoto důvodu se třídní typy bez uvedeného typu musí alokovat na haldě. Tento princip platí i u kontejnerů a vždy je lepší specifikovat typ ukládaných objektů.\cite{julia-performance}

Jako ve většině programovacích jazyků je i v Julii možné definovat si vlastní typy.

Složené typy jsou v Julii realizované strukturami, které téměř totožné se strukturami z jazyka C. Tyto struktury a jejich členské proměnné jsou implicitně \textit{immutable} (česky neměnné). Pokud jsou immutable členskými proměnnými složené typy (např. pole), pak lze měnit jejich obsahy, protože immutable jsou pouze reference na tyto objekty a ne objekty samotné. Pokud nechceme, aby byla deklarovaná struktura immutable, pak použijeme klíčové slovo \texttt{mutable} před deklarací struktury. Implicitní neměnnost nemusí být na škodu, poskytují mnoho nezanedbatelných výhod, např. snadnější srozumitelnost kódu a výkonnost plynoucí z toho, že neměnné objekty v některých případech není potřeba alokovat na haldu. Tohoto se využívá v naší implementaci, objekty pro sestrojení aproximace jsou vždy neměnné, ačkoliv v sobě obsahují pole se vstupními daty. Všechny struktury mají implicitní konstruktor s totožným názvem a přijímají tolik argumentů, kolik má struktura členských proměnných a v takovém pořadí, v jakém jsou deklarovány jednotlivé členské proměnné. Konstruktory si lze samozřejmě dodefinovat dle potřeby.

V Julii se immutable objekty předávají do funkcí hodnotou, zatímco mutable objekty se předávají referencí. Proměnné samy o sobě žádný typ nemají, jsou pouze ,,pojmenováním'' nějakého objektu. Tedy například sekvence příkazů
\begin{Verbatim}
a = 3 # typeof(a) -> Int64
a = "Ahoj" # typeof(a) -> String
a = 4.0 # typeof(a) -> Float64
\end{Verbatim}
žádnou chybu nevyvolá. Pokud se ovšem proměnné určíme typ operátorem \texttt{::}, pak už do ní nelze přiřadit hodnotu s jiným typem. Toto je znázorněno na příkladu \ref{julia-example:cannot-override-declared-types}. Globálním proměnným (tedy i proměnným v terminálovém prostředí) nelze přiřadit typ, proto jsme založili dočasnou funkci. Mohlo by nás napadnout, proč se úspěšně podařilo definovat funkci \texttt{foo} (indikováno na řádku 5 v příkladu), přestože v sobě obsahuje chybu. Důvodem je to, že definice funkce \texttt{foo} tělo funkce neprovedla. Chybné příkazy se vyvolaly teprve voláním funkce na řádku 7.
\begin{figure}
  \renewcommand{\figurename}{Příklad}
  \label{julia-example:cannot-override-declared-types}
  \begin{Verbatim}[numbers=left]
  julia> function foo()
           a::String = "Ahoj"
           a = 4
         end
  foo (generic function with 1 method)

  julia> foo()
  ERROR: MethodError: Cannot `convert` an object of type Int64
  to an object of type String...
  \end{Verbatim}
  \caption{Pokus o předefinování typu proměnné.}
\end{figure}

Objektově orientované paradigma je v Julii realizováno poněkud netradičním způsobem. Abstraktní typy se deklarují klíčovým slovem \texttt{abstract}, nemají žádné členské proměnné a slouží pouze jako ,,vrchol'' v grafu typů Julie. Dědit se smí pouze z abstraktních typů. Dá se tedy říct, že v Julii se dědičnost vztahuje pouze na chování objektů a nikoliv na členské proměnné. Účelem je sémanticky svázat chování různých objektů, které se mohou lišit implementací. Například funkce \texttt{transpose(A::Matrix)} dokáže transponovat libovolný druh matice.

V práci se pro různé účely často používá pole, které se může chováním může lišit od všemožných programovacích jazyků a proto si jej popíšeme. Pole v Julii se indexují od 1. Existuje typ vícerozměrné pole, které nelze zaměňovat s polem polí. Pole v Julii jsou v paměti uložena ve sloupcově majoritním pořadí (stejně jako ve Fortranu). Pragmaticky to například znamená, že pokud se iteruje přes dvourozměrné pole velikosti 3 řádky a 2 sloupce, pak by se mělo nejprve iterovat přes sloupec sloupec a poté teprve řádek, tzn. $[1, 1], [2, 1], [3, 1], [1, 2], [2, 2], [3, 2]$, kde první index značí řádek a druhý sloupec. 

Julia má vestavěnou funkcionalitu pro vytváření dokumentace. Před definice funkcí a struktur lze vytvořit řetězec, který bude obsahovat dokumentaci k definovanému objektu. Tuto dokumentaci lze v terminálovém příkazu otevřít pomocí příkazu \texttt{?<název objektu>}. Tuto vlastnost demonstrujeme na příkladu \ref{julia-example:documentation}. Všimněme si, že stisknutí otazníku změní prompt z \texttt{julia>} na \texttt{help?>}.
\begin{figure}
  \renewcommand{\figurename}{Příklad}
  \label{julia-example:documentation}
  \begin{Verbatim}
julia> """
       This is sample documentation of Foo.
       """struct Foo end

help?> Foo
search: ....

  This is sample documentation of Foo.
  \end{Verbatim}
  \caption{Demonstrace vestavěné dokumentace v Julii.}
\end{figure}

\section{Použité externí knihovny}

Při implementaci byly použity následující externí knihovny:
\begin{itemize}
  \item \texttt{DynamicPolynomials} a \texttt{MultivariatePolynomials} poskytují třídy pro práci s polynomy.
  \item \texttt{NearestNeighbors} poskytuje implementaci k-d stromu.
  \item \texttt{DataStructures} poskytuje spojový seznam.
  \item \texttt{Plots} umožňuje vykreslování grafů.
\end{itemize}

Při implementaci a testování se používal \texttt{Jupyter}, který v prohlížeči vytvoří interaktivní prostředí. Terminálové prostředí je nevhodné pro tvorbu rozsáhlejších programů, které se často pouštějí vícekrát, což by znamenalo ruční přepisování příkazů při každém provádění. Na druhou stranu modifikovat skripty často znamená, že i při malých změnách se musí znovu provést interpretace celého skriptu. Navíc je obtížné nechat si k jednotlivým příkazům zobrazit jejich dílčí výstupy. \texttt{Jupyter} kombinuje oba přístupy a umožňuje snadnou modifikaci skriptů (zvané notebooky), zobrazování výstupu každého příkazu a možnost ukládat si posloupnosti příkazů.

\section{Implementace cell linked listu}

TODO: Nějaká omáčka o nereálných implementacích z teoretické části sem.

V teoretické části se pro reprezentaci mřížky cell linked listu použilo nekonečně velké pole, což může být v praxi překážkou. Nechť je dána sada vektorů $S := \{\vec{x_i}\}_{i=1}^n$, kde $\vec{x_i} \in \reals^d$ a cell linked list $C$ s daným parametrem $\varepsilon(C)$. Chceme určit minimální možnou velikost mřížky $G(C)$ tak, aby v ní bylo možné uchovat všechny vektory z množiny $S$. Zaveďme značení $\min(V)$ a $\max(V)$, čímž se myslí nejmenší resp. největší vektor z nějaké množiny vektorů $V$. Je přiřozené, aby vektor $\min(S)$ měl souřadnice $(0, \ldots, 0)^T$. Proto v implementaci je modifikována funkce $I(C, \vec{u}), \vec{u} \in S$ a její výsledek je dán vztahem
\begin{equation}
  \label{cll-index}
  I_m(C, \vec{u}) = I(C, \vec{u}) - I(C, \min(S(C))) + (1, \ldots, 1).
\end{equation}
V Julii se pole indexují od 1, proto je k výsledku \ref{cll-index} přičten jednotkový vektor. Velikost mřížky, která je potřeba k uchování celé sady $S$ získáme spočtením funkce $I(C, \max(S))$.

Další implemenační problém nastal při hledání sousedů. Velikost mřížky $G(C)$ je často o mnoho větší než počet buněk obsahující vektory, které chceme prohledat. Nechť je dán vektor $\vec{q}$, ke kterému chceme nalézt všechny vektory cell linked listu $C$ vzdálené maximálně o $\delta \in \reals$. Určeme souřadnice $c = I_m(C, \vec{q})$. Místo naivní iterace přes celou mřížku $G(C)$ budeme pouze iterovat přes takové buňky $b \in G(C)$, které mají 

\section{Implementace metody pohyblivých vážených nejmenších čtverců}

Těžištěm implementace je objekt \texttt{MwlsObject}, který si uchovává potřebné vstupy pro výpočet požadovaných aproximací. Mezi jeho atributy patří:
\begin{itemize}
  \item \texttt{inputs} -- sada vstupních dat $\{\vec{x_i}\}_{i=1}^k, x_i \in \reals^n$,
  \item \texttt{outputs} -- sada výstupních dat $\{\vec{y_i}\}_{i=1}^k, y_i \in \reals^m$,
  \item \texttt{EPS} -- reálná hodnota udávající implicitní velikost ,,okolí'' pro konstrukci aproximace,
  \item \texttt{weightFunc} -- váhová funkce pro konstrukci aproximace.
\end{itemize}
Atributy \texttt{inputs} a \texttt{outputs} lze předat dvěma způsoby, buď jako dvě různá vícerozměrná pole, nebo jedním vícerozměrným polem a kladným celočíselným parametrem, které udává dimenzi výstupních dat. Ačkoliv si Julia uchovává vícerozměrná pole ve sloupcové majoritě, tak se na vstupu očekávají data tak, že dvojice vstupů a výstupů jsou na jednom řádku.

Třída \texttt{MwlsObject} má 3 různé implementace, které se liší způsobem hledání sousedů v rozsahu. Struktura \texttt{MwlsNaiveObject} používá k hledání naivní iteraci přes celou množinu vstupních dat, \texttt{MwlsCllObject} používá cell linked list a \texttt{MwlsKdObject} používá k-d strom. Pro snadnější vytvoření jednotlivých objektů jsou připraveny pomocné funkce \texttt{mwlsNaive}, \texttt{mwlsCll} a \texttt{mwlsKd}.

V teoretické části se pro aproximaci používala (téměř) libovolná sada funkcí $f_1, \ldots, f_l$. V implementaci se však pouze předá celočíselný parametr \texttt{maxDegree}, který určuje maximální stupeň \textit{polynomiální báze} \texttt{b} použité k aproximaci v každé z jednotlivých dimenzí. Demonstrujeme na příkladu \ref{exer:basis-example}.
\begin{priklad}
  \label{exer:basis-example}
  Pro parametr $\texttt{maxDegree} = 2$ a dimenzi výstupních dat $m = 2$ se vytvoří sada funkcí $f_1(x_1, x_2), \ldots, f_{12}(x_1, x_2)$
  \begin{multline}
    f_1 = (1, 0), f_2 = (x, 0), f_3 = (y, 0), f_4 = (x^2, 0), f_5 = (xy, 0), f_6 = (y^2, 0),\\
    f_7 = (0, 1), f_8 = (0, x), f_9 = (0, y), f_{10} = (0, x^2), f_{11} = (0, xy), f_{12} = (0, y^2)\\
  \end{multline}
  která bude použita pro konstrukci aproximace.
\end{priklad}
Lze si však všimnout, že se mnoho funkcí často opakuje a liší se pouze ve složce, která je nenulová. Proto budeme generovat bázi tak, aby se funkce neduplikovaly. Výsledkem příkladu \ref{exer:basis-example} tedy bude pouze $f_1(x, y) = 1, f_2(x, y) = x, f_3(x,y) = y, f_4(x,y)=x^2,f_5=xy,f_6=y^2$.

Přejděme k implementaci výpočtu matice $\mx{A}$ a vektoru $\vec{b}$ z rovnice \ref{eq:sle-mwls}. Jak již bylo naznačeno, mnoho funkcí se v polynomiální bázi použité k aproximaci opakuje. Proto se místo vektoru $\vec{b}$ použije matice $\mx{B}$, kde v řádcích jsou jednotlivé výstupní vektory $y_i$.

